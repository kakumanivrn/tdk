TDK 3.0 Checker Xref / Frontend
===============================

The frontend uses the cross-reference data generated by the backend
[1] to allow the user to explore a set of sources (application,
library, or a mix thereof).


Use cases
---------

1.	Explain I ...

	The user is using an editor of some kind, and selects a
	character or range of characters in a file he has open in that
	editor. He wishes to obtain information about the characters
	in the range or surrounding it. I.e. what commands / variables
	/ namespaces / classes are used / defined at the selected
	location.

2.	Explain II ...

	Like use case (1), except that not the range is important, but
	rather the characters in that range. IOW, a general search for
	the word is done in the entire database and all relevant
	entities are returned, definitions and usages ...


3.	Explore I, Basics

	The user will likely wish to see lists for the known entities,
	showing what is present in the database, and basic information
	about it.

	-	The lists have to allow filtering in various ways to
		reduce the amount of information displayed and make
		comprehension easier.

	A combination of such lists can be used to display the results
	of the searches run for (1) and (2).

4.	Explore II

	When a list is present selections are possible, and the user
	will wish to see more detailed information ... I.e. full lists
	for the locations an entity is defined and/or used at,
	entities the current one relates to, etc.

	This might require communication to the editor to display
	specific locations. If that is not possible the frontend will
	have to display the file and location therein. ... This is
	also required if there is no editor at all, i.e. the frontend
	acting standalone.

	Based on a shown entity and locations searches like for use
	case (1) and (2) can yield connected entities to switch the
	display to. As can additional relationships stored in the
	database itself.


5.	Explore III

	Show the network of relationships graphically, either
	partially or in full.



User Interface(s)
-----------------

The main interface for use case (1) is the chosen editor itself. It
has to have the ability to select a character range, and then to
invoke a function for that range. The first is standard, the latter
changes from editor to editor. The main question is how to convey the
request from the editor to the cross-reference tool. The most common
way of extending an editor is by calling out to external
applications. This is what we should do here too [2]. The information
coming as part of the request should contain: file name, line, and
selected range (indices into the file).

We have to think about what application to start for the request. The
frontend itself ? It will have to be able to determine if it is
already running, to prevent multiple instances from interfering with
each other. On the other hand, multiple instaces might very well what
we need if different projects are investigated ... The alternative is
run a small communication application which simply talks to the
frontend. Even that might have to be able to start the full frontend
if it is not running.

Other items to think about: How and when is the cross-reference
database generated ? Should the database be persistent ?

Example: Generate the database at the time the frontend starts up, in
other words, when the first query is made.

Example: Simply load a persistent database when the frontend starts up.

Disadvantage of the persistency: Might be out of date. ... Check
times, look for deleted or new files to ascertain the state of the
database with repsect to the code it is based on.

Should the database be updated on the fly when changes are made in the
editor ? Is that even possible efficiently ?

Here the choice of an md5 hash of a file as its id comes to bite
us. The id is cont. changing as the file is changing. This means that
the in-memory database should use other, unchanging, id's for the
internal references. It does help when determining if the db is out of
date.


How to display the result of the request: In the editor ? This
requires two-way communication between cross reference too and
editor. It is not known if this is possible. So the other option is to
have to the tool itself open a window containing the requested
information. [[[ This needs more detail ]]]


Use case (2) is essentially the same as (1), except that the search
operation to be performed is different. Not location based, but string
based.


Use cases (3) and (4): It seems that an interface like for
TkInspect/proinspect is warranted ... Lists of entities, source code /
details below the lists ... multiple displays configured differently
... Another possibility to investigate is the interface provided by
Source Navigator ...


Questions
---------

Questiona a user might ask while exploring a project = cross reference
database for a set of files ... This is important for the use cases
(3) and (4).

a.1	  What files ?		Restricted by pattern match on names ...
a.2	  What entities are used in a specific file ?
a.3	  What entities are defined in a specific file ?

b.1	  What commands ?	Restricted by pattern match on names.
b.2	  Where is a command defined ?	file + location, container
b.3	  Who uses a command ?		other commands, their locations.
b.4	  What variables are related to the command ? Complement c.2/3

c.1	  What variables ?   Restricted by pattern match on names.
c.2	  Where is a variable used ?  file + location, also commands and containers.
c.3	  Where is a variable defined ? s.a.
c.4	  What other variables it is related to ? ... imported from, imported by

d.1	  What namespaces ?    Restricted by pattern match.
d.2	  Where used ?	  file + location, commands, ...
d.3.	  Where defined ? file + location
d.4	  What variables ?		Complement c.2/3
d.5	  What commands in it ? ... Complement b.2




Implementation thoughts
-----------------------

To be efficient use case (1) requires a mapping from file locations to
the entities defined or used at that location. The data provided to us
contains a mapping from entities to locations. This means that the
frontend has to create a reverse mapping from the data it receives.

An index for every file and character location in that file to
entities would be the fastest method, requiring only one lookup per
selected character to find all relevant data. It would also require
quite a lot of memory, prohibitively so.

A less memory intensive index would consists of two indices. The first
is keyed by file and relevant line numbers. The data per key are a
list of ranges starting on the line in the key, in the given
file. After looking this up we can restrict the ranges to the range
selected by the user.

The second index is keyed by file and range and maps to lists of the
entitities for that range. Actually to specific data, definition or
usage, in the main database.

A single index, keyed by file and line is possible, but has to refer
to all possible entitities for that line. The restriction to the range
of selected characters requires more effort (more objects to handle,
in disparate sections of the main database).

A single index keyed by file and character range is unsuitable,
because the whole index has to be searched for matching ranges.


Use case (2) requires a different index: Not files and locations are
key, but words, like the names of commands, variables, etc.





Foot notes
----------

[1]	The backend is 'procheck', extended to generate
	cross-reference information. This mode is invoked via the
	option -xref.

	See	TDK_3.0_Checker_Xref.txt
		TDK_3.0_Checker_Xref_Data.txt
		TDK_3.0_Checker_Xref_Notes.txt
		TDK_3.0_Checker_Xref_Var.txt

[2]	Our goal is integration with Komodo. As there is no Tcl
	binding allowing us to directly hook into Komodo functionality
	with our scripts an external application is the only way to
	go.
