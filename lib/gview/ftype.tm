# Copyright (c) 2018 ActiveState Software Inc.
# Released under the BSD-3 license. See LICENSE file for details.
#
# -- Tcl Module

# @@ Meta Begin
# Package ftype 1.0
# Meta platform    tcl
# Meta require     csv
# Meta require     file::open
# Meta require     ico
# Meta require     image
# Meta require     image::tint
# Meta require     snit
# @@ Meta End

# -*- tcl -*-
# -*- tcl -*-
# ### ######### ###########################

# Tools. Determine icon for a file, based on its extension.

# ### ######### ###########################
## Prerequisites

package require snit; # Object-system.
package require image::tint
package require image       ; image::file::here
package require ico
package require csv

snit::type ftype {
    # ### ######### ###########################

    # ### ######### ###########################
    ## Public API. (De)Construction.

    constructor {args} {
	# A short map from common extensions to icons.

	array set ext {
	    .dll dll
	    .exe exe
	    .txt txt
	    _folder folder
	    _nonfile txt
	}

	# The internal icon image database. Maps from the icon names
	# generated by the object to their Tk images

	array set ico  {}

	# Path cache. Maps from prefix + path to the icon for the
	# path.

	array set fmap {}

	# Predefined icons for selected items, based on 'ext'.

	foreach img {dll exe txt file folder} {
	    image::tint::define  small-${img}Sel small-$img
	    image::tint::define  big-${img}Sel   big-$img
	}
	#$self configurelist $args

	# Register ourselves as a source of images. We use this to
	# ensure that the images we extract from the files themselves
	# will be found. I.e. through us.

	::image::plugin [mymethod GetICO]
	return
    }

    destructor {
	if {$jid ne ""} {after cancel $jid}
	return
    }

    # ### ######### ###########################

    variable ext     ; # Quick icon assignment through file extension
    variable ico     ; # Icon database provided here
    variable fmap    ; # Path/icon cache
    variable jobs {} ; # List of icon search jobs.
    variable jid  {} ; # After id of pending job handler.

    # ### ######### ###########################
    ## Public API. Map prefix and extension to icon

    method icon {prefix path} {
	if {[file isdirectory $path]} {
	    return ${prefix}-$ext(_folder)
	} elseif {![file isfile $path]} {
	    # Non-files (sockets, devices, ...) get a standard icon.
	    return ${prefix}-$ext(_nonfile)
	} else {
	    #puts stderr icon/$prefix/$path

	    if {[info exists fmap($prefix,$path)]} {
		return $fmap($prefix,$path)
	    }

	    ## At this point we have exhausted the quick sources
	    ## for icons, and their Tk images.

	    ## Instead of doing a time-consuming search for the
	    ## icon right now we generate a Tk image in the
	    ## relevant size using a standard image/icon as source,
	    ## and register that as the icon for the file.

	    ## In addition we schedule a job for future execution
	    ## which tries to improve on the image. The important
	    ## thing is that this job will change the contents of
	    ## the Tk image we assign here, causing Tk to update
	    ## the UI. IOW this uses a notification system internal
	    ## to Tk. No need to change icon names, or image handles

	    set image [image create photo]
	    set icon $prefix-@/$self/$image/@
	    $self NeedBetterIcon $icon $prefix $path

	    set ico($icon) $image
	    $image copy [image::get [$self stdicon $prefix $path]]

	    set fmap($prefix,$path) $icon
	    image::tint::define ${icon}Sel $icon
	    return $icon
	}
	error "PANIC, must not arrive at this point"
	return
    }

    method stdicon {prefix path} {
	set e [file extension $path]
	if {[info exists ext($e)]} {
	    set icon ${prefix}-$ext($e)
	} else {
	    set icon ${prefix}-file
	}
	return $icon
    }

    method NeedBetterIcon {icon prefix path} {
	lappend jobs [list $icon $prefix $path]
	if {$jid ne ""} return

	set jid [after 100 [mymethod HandleJobs]]
	#puts stderr JOB/$jid/pending
	return
    }

    method HandleJobs {} {
	set jid ""
	if {![llength $jobs]} return

	#puts stderr JOB/todo

	# Get information of first job.

	foreach {icon prefix path} [lindex $jobs 0] break
	set jobs [lrange $jobs 1 end]

	if {[llength $jobs]} {
	    # Still jobs waiting, schedule more ...
	    set jid [after 100 [mymethod HandleJobs]]
	    #puts stderr JOB/$jid/pending
	}

	# And process the job ...

	#puts stderr JOB/$icon/$prefix|\t$path

	set newimage [$self GetIcon $prefix $path]

	#puts stderr \t=($newimage)

	if {$newimage != {}} {
	    #puts stderr \tcopy2\t$ico($icon)

	    # This update causes Tk to update the UI as well.
	    # No need to meddle with the dir/file views.

	    $ico($icon) blank
	    $ico($icon) copy $newimage
	    image delete $newimage

	    # If there is a selection icon defined for this one,
	    #,and already read (image present), then we play
	    # around with internals a bit to get this image
	    # updated as well.

	    if {[image::tint::hasimage ${icon}Sel]} {
		image::tint::define TEMP $icon
		set newtint [image::tint::get TEMP]
		set oldtint [image::tint::get ${icon}Sel]

		$oldtint blank
		$oldtint copy $newtint

		image::tint::undef TEMP
	    }
	}
	return
    }

    method GetIcon {prefix path} {
	set i [$self Embedded $prefix $path]
	if {$i ne ""} {return $i}

	set i [$self TDK $prefix $path]
	if {$i ne ""} {return $i}

	set i [$self Registry $prefix $path]
	# if {$i ne ""} {return $i}
	# Extensible ...
	# set i [... $prefix $path]
	return $i
    }

    method TDK {prefix path} {
	# Add code to recognize TDK specific files
	# (.tpj, .txr)

	return {}
    }

    method Registry {prefix path} {
	# Look in the registry for an executable associated
	# with the extension of the file. If there is one, then
	# look inside that executable for an embedded icon.

	# LocateApp - See 'devkit/app/vsfe/lib/tools/fopen.tcl'
	package require file::open

	set appCmd [file::LocateApp [file extension $path]]
	if {$appCmd == {}} {return {}}

	# The cmdline as stored by Windows is essentially as CSV
	# format using space as delimiter. A simple split is not
	# enough. Elements are possibly quoted using \".
	set appCmd [csv::split $appCmd { }]

	#puts stderr %%%|=--([join $appCmd ") ("])

	set application [lindex $appCmd 0]

	if {[file exists $application]} {
	    return [$self Embedded $prefix $application]
	}
	return {}
    }

    method Embedded {prefix path} {
	# Use ico to look for icons embedded into the file. If there
	# are any, get the first and use it as the image for the file.

	set icons {}
	set code [catch {set icons [ico::getIconList $path]}]
	if {$code || [llength $icons] == 0} { return }

	# Use prefix to select a properly sized icon.

	#puts stderr geticon/$icons

	if {$prefix eq "small"} {
	    set idx [$self Locate $icons 16]

	    #puts stderr geticon/match|$idx

	    if {$idx < 0} {
		# Try for a bigger one, and scale it down!
		set idx [$self Locate $icons 32]

		#puts stderr geticon/match|$idx

		if {$idx >= 0} {
		    #puts stderr geticon/scale/half

		    set big [ico::getIcon $path $idx]
		    set new [image create photo]
		    $new copy $big -subsample 2 2
		    $new redither
		    return $new
		}

		# Second try, even larger.

		set idx [$self Locate $icons 48]

		#puts stderr geticon/match|$idx

		if {$idx >= 0} {
		    #puts stderr geticon/scale/triple

		    set big [ico::getIcon $path $idx]
		    set new [image create photo]
		    $new copy $big -subsample 3 3
		    $new redither
		    return $new
		}
	    }
	} else {
	    set idx [$self Locate $icons 32]
	}

	#puts stderr geticon/match|$idx

	if {$idx < 0} {
	    # No good icon found. Fall back to the first one
	    return  [ico::getIcon $path 0]
	}

	return [ico::getIcon $path $idx]
    }

    method Locate {icons height} {
	# Of all icons for the height, use the one having the largest number of bpp.

	set maxbpp 0
	set idx   -1
	set j     -1
	foreach ic $icons {
	    incr j
	    foreach {w h bpp} $ic break
	    if {$h != $height} continue
	    if {$bpp > $maxbpp} {
		set maxbpp $bpp
		set idx $j
	    }
	}

	return $idx
    }

    # ### ######### ###########################

    method GetICO {name} {
	#puts stderr GetICO/$name

	if {![info exists ico($name)]} {return {}}

	#puts stderr \tok
	return $ico($name)
    }


    # ### ######### ###########################
}

# ### ######### ###########################
## Ready for use
return
